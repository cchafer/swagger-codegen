package {{invokerPackage}}

import java.net.URLEncoder
import java.security.cert.X509Certificate
import javax.net.ssl._

import akka.actor.ActorSystem
import akka.io.IO
import akka.pattern.ask
import akka.util.Timeout
import org.joda.time.DateTime
import org.joda.time.format.ISODateTimeFormat
import org.json4s.JsonAST.JString
import org.json4s.jackson.JsonMethods._
import org.json4s.{CustomSerializer, DefaultFormats, Serializer}
import spray.can.Http
import spray.can.Http.HostConnectorSetup
import spray.client.pipelining
import spray.client.pipelining._
import spray.http._
import spray.http.parser.HttpParser
import spray.httpx.encoding.{Encoder, Gzip}
import spray.httpx.unmarshalling._
import spray.io.ClientSSLEngineProvider

import scala.concurrent.ExecutionContext

object ApiInvoker {

  def apply()(implicit ec: ExecutionContext, system: ActorSystem): ApiInvoker = new ApiInvoker()

}

class ApiInvoker(implicit system: ActorSystem) extends UntrustedSslContext with CustomContentTypes {

  implicit val ec = system.dispatcher

  def settings = ApiSettings(system)

  import spray.http.MessagePredicate._

  val CompressionFilter = MessagePredicate({ _ => settings.compressionEnabled}) &&
    Encoder.DefaultFilter &&
    minEntitySize(settings.compressionSizeThreshold)

  def escape(value: String): String = URLEncoder.encode(value, "utf-8").replaceAll("\\+", "%20")

  def auth(credentials: Option[HttpCredentials]): pipelining.RequestTransformer =
    request => credentials.map(request ~> addCredentials(_)) getOrElse request


  def execute(basePath: String, r: ApiRequest) = {

    implicit val timeout: Timeout = settings.connectionTimeout
    val uri = r.uri(basePath)
    val connector = HostConnectorSetup(uri.authority.host.toString, uri.effectivePort, sslEncryption = "https".equals(uri.scheme))

    val formData = r.formParams
      .filter(k => k._2 != null)
      .map(k => escape(k._1) + "=" + escape(k._2))
      .mkString("", "&", "")

    val entity = HttpEntity.apply(formalizeContentType(r.contentType), formData)

    val request = HttpRequest(r.method, uri, r.headers, entity) ~>
      auth(r.credentials) ~>
      encode(Gzip(CompressionFilter))

    for {
      Http.HostConnectorInfo(hostConnector, _) <- IO(Http) ? connector
      response <- hostConnector.ask(request).mapTo[HttpResponse]
    } yield {
      response
    }

  }
}

trait JsonUnmarshalling {

  implicit val formats = DefaultFormats ++ ApiSerializers.all

  protected object ApiSerializers {
    def all = List[Serializer[_]](DateTimeSerializer)
  }

  protected case object DateTimeSerializer extends CustomSerializer[DateTime](format => ( {
    case JString(s) =>
      ISODateTimeFormat.dateTimeParser().parseDateTime(s)
  }, {
    case d: DateTime =>
      JString(ISODateTimeFormat.dateTimeParser().print(d))
  }))


  protected def registerStatusCode(statusCode: Int, detail: String = "", error: Boolean = false) = {
    StatusCodes.getForKey(statusCode) match {
      case None => StatusCodes.registerCustom(statusCode, detail, detail, error, true)
      case Some(status) => status
    }
  }

  protected def durationValue(response: HttpResponse): Option[Float] =
    response.headers.find(_.name equalsIgnoreCase "x-duration").map(_.value.toFloat)

  implicit def jsonableUnmarshaller[T](implicit mf: Manifest[T]): Unmarshaller[T] =
    Unmarshaller[T](MediaTypes.`application/json`) {
      case x: HttpEntity.NonEmpty ⇒
        parse(x.asString(defaultCharset = HttpCharsets.`UTF-8`))
          .camelizeKeys
          .extract[T]
    }

  def extractFromJsonResponse[T: FromResponseUnmarshaller](response: HttpResponse): T = {
    response.as[T] match {
      case Right(value) ⇒ value
      case Left(error) ⇒
        throw new ApiError(s"$error. Received : (${response.status}) ${response.entity.toString}", null, durationValue(response))
    }
  }

}

object ApiUtils {

  // Can be completed for specific string encoding, i.e dates
  object Mappable {

    implicit class MapOps[A, B](val m: Map[String, String]) extends AnyVal {
      def add(k: String, a: AnyRef): Map[String, String] = a match {
        case None => m
        case Some(default) => m + (k -> default.toString)
        case default => m + (k -> default.toString)
      }
    }

  }

}

trait CustomContentTypes {

  def formalizeContentType(original: String): ContentType =
    MediaTypes.forExtension(original) map (ContentType(_)) getOrElse parseContentType(original)

  def parseContentType(contentType: String): ContentType = {
    val contentTypeAsRawHeader = HttpHeaders.RawHeader("Content-Type", contentType)
    val parsedContentTypeHeader = HttpParser.parseHeader(contentTypeAsRawHeader)
    (parsedContentTypeHeader: @unchecked) match {
      case Right(ct: HttpHeaders.`Content-Type`) =>
        ct.contentType
      case Left(error: ErrorInfo) =>
        throw new IllegalArgumentException(
          s"Error converting '$contentType' to a ContentType header: '${error.summary}'")
    }
  }
}

trait UntrustedSslContext {
  this: ApiInvoker =>

  implicit lazy val trustfulSslContext: SSLContext = {
    settings.alwaysTrustCertificates match {
      case false =>
        SSLContext.getDefault

      case true =>
        class IgnoreX509TrustManager extends X509TrustManager {
          def checkClientTrusted(chain: Array[X509Certificate], authType: String): Unit = {}

          def checkServerTrusted(chain: Array[X509Certificate], authType: String): Unit = {}

          def getAcceptedIssuers = null
        }

        val context = SSLContext.getInstance("TLS")
        context.init(null, Array(new IgnoreX509TrustManager), null)
        context
    }
  }

  implicit val clientSSLEngineProvider =
    ClientSSLEngineProvider {
      _ =>
        val engine = trustfulSslContext.createSSLEngine()
        engine.setUseClientMode(true)
        engine
    }
}