package {{invokerPackage}}

import java.io.File
import java.net.URLEncoder
import java.security.cert.X509Certificate
import javax.net.ssl._

import akka.actor.ActorSystem
import akka.io.IO
import akka.pattern.ask
import akka.util.Timeout
import org.json4s.ext.JodaTimeSerializers
import org.json4s.jackson.JsonMethods._
import org.json4s.jackson.Serialization
import org.json4s.{DefaultFormats, Extraction}
import spray.can.Http
import spray.can.Http.HostConnectorSetup
import spray.client.pipelining
import spray.client.pipelining._
import spray.http.HttpEncodings._
import spray.http.HttpHeaders.{RawHeader, `Accept-Encoding`}
import spray.http.Uri.Query
import spray.http._
import spray.http.parser.HttpParser
import spray.httpx.encoding.{Deflate, Encoder, Gzip}
import spray.httpx.unmarshalling._
import spray.io.ClientSSLEngineProvider

import scala.concurrent.{ExecutionContext, Future}

trait ApiModel

object ApiInvoker {

  def apply()(implicit ec: ExecutionContext, system: ActorSystem): ApiInvoker = new ApiInvoker()

  case class NumericValue(value: String) {
    override def toString = value
  }

  object NumericValue {
    def unapply(n: Any): Option[NumericValue] = n match {
      case (_: Int | _: Long | _: Float | _: Double | _: Boolean | _: Byte) => Some(NumericValue(String.valueOf(n)))
      case _ => None
    }
  }

  case class CustomStatusCode(value: Int, reason: String = "Application-defined status code", isSuccess: Boolean = true)

  sealed trait CollectionFormat

  trait MergedArrayFormat extends CollectionFormat {
    def separator: String
  }

  case object CSV extends MergedArrayFormat {
    override val separator = ","
  }

  case object TSV extends MergedArrayFormat {
    override val separator = "\t"
  }

  case object SSV extends MergedArrayFormat {
    override val separator = " "
  }

  case object PIPES extends MergedArrayFormat {
    override val separator = "|"
  }

  case object MULTI extends CollectionFormat

  case class ArrayValues(values: Seq[Any], format: CollectionFormat = CSV)

  object ArrayValues {
    def apply(values: Option[Seq[Any]], format: CollectionFormat): ArrayValues =
      ArrayValues(values.getOrElse(Seq.empty), format)

    def apply(values: Option[Seq[Any]]): ArrayValues = ArrayValues(values, CSV)
  }

  implicit class ParametersMapImprovements(val m: Map[String, Any]) {

    private def urlEncode(v: Any) = URLEncoder.encode(String.valueOf(v), "utf-8").replaceAll("\\+", "%20")

    private def formattedParams(tuple: (String, Any)): Seq[(String, Any)] = formattedParams(tuple._1, tuple._2)

    private def formattedParams(name: String, value: Any): Seq[(String, Any)] = value match {
      case arr: ArrayValues =>
        arr.format match {
          case MULTI => arr.values.flatMap(formattedParams(name, _))
          case format: MergedArrayFormat => Seq((name, arr.values.mkString(format.separator)))
        }
      case None => Seq.empty
      case Some(opt) =>
        formattedParams(name, opt)
      case s: Seq[Any] =>
        formattedParams(name, ArrayValues(s))
      case v: String => Seq((name, urlEncode(v)))
      case NumericValue(v) => Seq((name, urlEncode(v)))
      case f: File => Seq((name, f))
      case m: ApiModel => Seq((name, m))
    }

    def asFormattedParamsList = m.toList.flatMap(formattedParams)

    def asFormattedParams = m.flatMap(formattedParams)
  }

  def addCustomStatusCode(code: CustomStatusCode): Unit = addCustomStatusCode(code.value, code.reason, code.isSuccess)

  def addCustomStatusCode(code: Int, reason: String = "Application defined code", isSuccess: Boolean = true) = {
    if (StatusCodes.getForKey(code).isEmpty)
      StatusCodes.registerCustom(code, reason, reason, isSuccess, allowsEntity = true)
  }

}

sealed trait Credentials {
  def asQueryParam: Option[(String, String)] = None
}

sealed trait ApiKeyLocation

object ApiKeyLocations {

  case object Query extends ApiKeyLocation

  case object Headers extends ApiKeyLocation

}

case object NoCredentials extends Credentials

sealed case class ApiKeyValue(value: String)

sealed case class ApiKeyCredentials(key: ApiKeyValue, keyName: String, location: ApiKeyLocation) extends Credentials {
  override def asQueryParam: Option[(String, String)] = location match {
    case ApiKeyLocations.Query => Some((keyName, key.value))
    case _ => None
  }
}

sealed case class BasicCredentials(user: String, password: String) extends Credentials

case object EmptyContent

sealed case class ApiError(code: Int, message: String) extends Throwable(message)

sealed case class ApiResponse[T](code: Int, content: T, headers: Map[String, String] = Map.empty)

sealed case class ApiEmptyResponse(code: Int, headers: Map[String, String] = Map.empty)


class ApiInvoker(implicit system: ActorSystem) extends UntrustedSslContext with CustomContentTypes with JsonUnmarshalling {

  import io.swagger.client.core.ApiInvoker._

  implicit val ec = system.dispatcher
  implicit val defaultFormats = formats

  def settings = ApiSettings(system)

  import spray.http.MessagePredicate._

  val CompressionFilter = MessagePredicate({ _ => settings.compressionEnabled}) &&
    Encoder.DefaultFilter &&
    minEntitySize(settings.compressionSizeThreshold)

  settings.customCodes.foreach(addCustomStatusCode)

  private def addAuthentication(credentials: Credentials): pipelining.RequestTransformer =
    request =>
      credentials match {
        case BasicCredentials(login, password) =>
          request ~> addCredentials(BasicHttpCredentials(login, password))

        case ApiKeyCredentials(keyValue, keyName, ApiKeyLocations.Headers) =>
          request ~> addHeader(RawHeader(keyName, keyValue.value))

        case _ => request
      }

  private def addHeaders(headers: Map[String, Any]): pipelining.RequestTransformer = { request =>

    val rawHeaders = for {
      (name, value) <- headers.asFormattedParams
      header = RawHeader(name, String.valueOf(value))
    } yield header

    request.withHeaders(rawHeaders.toList)
  }

  private def bodyPart(name: String, value: Any): BodyPart = {
    value match {
      case f: File =>
        BodyPart(f, name)
      case v: String =>
        BodyPart(HttpEntity(String.valueOf(v)))
      case NumericValue(v) =>
        BodyPart(HttpEntity(String.valueOf(v)))
      case m: ApiModel =>
        BodyPart(HttpEntity(Serialization.write(m)))
    }
  }

  private def formDataContent(request: ApiRequest) = {
    val params = request.formParams.asFormattedParams
    if (params.isEmpty)
      None
    else
      Some(
        normalizedContentType(request.contentType).mediaType match {
          case MediaTypes.`multipart/form-data` =>
            MultipartFormData(params.map { case (name, value) => (name, bodyPart(name, value))})
          case MediaTypes.`application/x-www-form-urlencoded` =>
            FormData(params.mapValues(String.valueOf))
          case m: MediaType => // Default : application/x-www-form-urlencoded.
            FormData(params.mapValues(String.valueOf))
        }
      )
  }

  private def bodyContent(request: ApiRequest): Option[Any] = {
    request.bodyParam.map(Extraction.decompose).map(compact)
  }

  private def createRequest(uri: Uri, request: ApiRequest): HttpRequest = {
    val builder = new RequestBuilder(request.method)

    val httpRequest = request.method match {
      case HttpMethods.GET | HttpMethods.DELETE => builder.apply(uri)
      case HttpMethods.POST | HttpMethods.PUT =>
        formDataContent(request) orElse bodyContent(request) match {
          case Some(c: FormData) =>
            builder.apply(uri, c)
          case Some(c: MultipartFormData) =>
            builder.apply(uri, c)
          case Some(c: String) =>
            builder.apply(uri, HttpEntity(normalizedContentType(request.contentType), c))
          case _ =>
            builder.apply(uri, HttpEntity(normalizedContentType(request.contentType), " "))
        }
      case _ => builder.apply(uri)
    }

    httpRequest ~>
      addHeaders(request.headerParams) ~>
      addAuthentication(request.credentials) ~>
      encode(Gzip(CompressionFilter))
  }

  def makeQuery(r: ApiRequest): Query = {
    (r.queryParams ++ r.credentials.asQueryParam)
      .asFormattedParams
      .mapValues(String.valueOf)
      .foldRight[Query](Uri.Query.Empty) {
      case ((name, value), acc) => acc.+:(name, value)
    }
  }

  def makeUri(r: ApiRequest): Uri = {
    val opPath = r.operationPath.replaceAll("\\{format\\}", "json")
    val opPathWithParams = r.pathParams.asFormattedParams
      .mapValues(String.valueOf)
      .foldLeft(opPath) {
      case (path, (name, value)) => path.replaceAll(s"\\{$name\\}", value)
    }
    val query = makeQuery(r)

    Uri(r.basePath + opPathWithParams).withQuery(query)
  }

  def execute(r: ApiRequest) = {

    try {
      implicit val timeout: Timeout = settings.connectionTimeout

      val uri = makeUri(r)

      val connector = HostConnectorSetup(
        uri.authority.host.toString,
        uri.effectivePort,
        sslEncryption = "https".equals(uri.scheme),
        defaultHeaders = settings.defaultHeaders ++ List(`Accept-Encoding`(gzip, deflate)))

      val request = createRequest(uri, r)
      System.out.println("# Request : " + request)

      for {
        Http.HostConnectorInfo(hostConnector, _) <- IO(Http) ? connector
        response <- hostConnector.ask(request).mapTo[HttpResponse]
      } yield {
        response ~> decode(Deflate) ~> decode(Gzip)
      }
    }
    catch {
      // TODO mettre un truc plus joli ici...
      case x: Throwable => Future.failed(x)
    }
  }
}

trait JsonUnmarshalling {

  implicit val formats = DefaultFormats ++ JodaTimeSerializers.all

  // TODO encore utilisé ?
  protected def durationValue(response: HttpResponse): Option[Float] =
    response.headers.find(_.name equalsIgnoreCase "x-duration").map(_.value.toFloat)

  implicit def jsonableUnmarshaller[T](implicit mf: Manifest[T]): Unmarshaller[T] =
    Unmarshaller[T](MediaTypes.`application/json`) {
      case x: HttpEntity.NonEmpty ⇒
        parse(x.asString(defaultCharset = HttpCharsets.`UTF-8`))
          .camelizeKeys
          .extract[T]
    }

  def extractFromJsonResponse[T: FromResponseUnmarshaller](response: HttpResponse)(implicit m: Manifest[T]): T = {
    response.as[T] match {
      case Right(value) ⇒ value
      case Left(error) ⇒
        throw new ApiError(response.status.intValue,
          s"$error - Expected: ${m.runtimeClass.getName} data. Content : "
            + (if (response.entity.toString.length > 500) response.entity.toString.take(500) + "..." else response.entity.toString))
    }
  }

}

trait CustomContentTypes {

  def normalizedContentType(original: String): ContentType =
    MediaTypes.forExtension(original) map (ContentType(_)) getOrElse parseContentType(original)

  def parseContentType(contentType: String): ContentType = {
    val contentTypeAsRawHeader = HttpHeaders.RawHeader("Content-Type", contentType)
    val parsedContentTypeHeader = HttpParser.parseHeader(contentTypeAsRawHeader)
    (parsedContentTypeHeader: @unchecked) match {
      case Right(ct: HttpHeaders.`Content-Type`) =>
        ct.contentType
      case Left(error: ErrorInfo) =>
        throw new IllegalArgumentException(
          s"Error converting '$contentType' to a ContentType header: '${error.summary}'")
    }
  }
}

trait UntrustedSslContext {
  this: ApiInvoker =>

  implicit lazy val trustfulSslContext: SSLContext = {
    settings.alwaysTrustCertificates match {
      case false =>
        SSLContext.getDefault

      case true =>
        class IgnoreX509TrustManager extends X509TrustManager {
          def checkClientTrusted(chain: Array[X509Certificate], authType: String): Unit = {}

          def checkServerTrusted(chain: Array[X509Certificate], authType: String): Unit = {}

          def getAcceptedIssuers = null
        }

        val context = SSLContext.getInstance("TLS")
        context.init(null, Array(new IgnoreX509TrustManager), null)
        context
    }
  }

  implicit val clientSSLEngineProvider =
    ClientSSLEngineProvider {
      _ =>
        val engine = trustfulSslContext.createSSLEngine()
        engine.setUseClientMode(true)
        engine
    }
}
